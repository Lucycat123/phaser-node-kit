{
    "docs": [
        {
            "location": "/",
            "text": "Phaser Node Kit\n\n\n\n\nRapid Game Development with Phaser and Node\n\n\nWhat Is It?\n\n\nPhaser Node Kit\n is a fairly opinionated workflow and build tool for creating \nPhaserJS\n games using \nNodeJS\n.\n\n\nYou may be asking yourself, why? And that I can't answer clearly. I just spend most of my time in the \nNode\n environment.\n\n\nThe build tool is basically a collection of some popular libraries to get your game built for distribution using \nNode\n.\n\n\nThe major components consist of:\n\n\nNodeJS\n\n\nBabel\n\n\nBrowserify\n\n\nand of course...\n\n\nPhaserJS\n\n\nHow It Works\n\n\nOn each build cycle your javascript code is compiled to a \nBrowserify\n bundle ready to play. The \nphaser.js\n file is gathered from \nnpm\n and added as a vendor file during the initial creation of your project.\n\n\nPhaser Node Kit imposes a minimal workflow. For straight forward game development the workflow should prove accommodating. See the \nWorkflow\n section for more details.",
            "title": "Overview"
        },
        {
            "location": "/#phaser-node-kit",
            "text": "Rapid Game Development with Phaser and Node",
            "title": "Phaser Node Kit"
        },
        {
            "location": "/#what-is-it",
            "text": "Phaser Node Kit  is a fairly opinionated workflow and build tool for creating  PhaserJS  games using  NodeJS .  You may be asking yourself, why? And that I can't answer clearly. I just spend most of my time in the  Node  environment.  The build tool is basically a collection of some popular libraries to get your game built for distribution using  Node .  The major components consist of:  NodeJS  Babel  Browserify  and of course...  PhaserJS",
            "title": "What Is It?"
        },
        {
            "location": "/#how-it-works",
            "text": "On each build cycle your javascript code is compiled to a  Browserify  bundle ready to play. The  phaser.js  file is gathered from  npm  and added as a vendor file during the initial creation of your project.  Phaser Node Kit imposes a minimal workflow. For straight forward game development the workflow should prove accommodating. See the  Workflow  section for more details.",
            "title": "How It Works"
        },
        {
            "location": "/install/",
            "text": "Installation\n\n\nPhaser Node Kit\n is a \nNode\n command line application that is installed globally making the tool at the ready for when creative game sparks fly.\n\n\nYou can have a running game development framework up in a handful of seconds.\n\n\nRequirements\n\n\nTo run Phaser Node Kit you will need \nNodeJS\n version 6 or higher. You can download the latest releases from the site at \nhttps://nodejs.org\n.\n\n\nnpm\n\n\nUsing the \nnpm\n package manager (included with NodeJS), run the following on the command line:\n\n\nsudo npm i -g phaser-node-kit\n\n\nThis will install the tool, and make it available anywhere on the command line as \npnkit\n.\n\n\nYou can get the latest version information to be certain its installed:\n\n\npnkit -v",
            "title": "Installation"
        },
        {
            "location": "/install/#installation",
            "text": "Phaser Node Kit  is a  Node  command line application that is installed globally making the tool at the ready for when creative game sparks fly.  You can have a running game development framework up in a handful of seconds.",
            "title": "Installation"
        },
        {
            "location": "/install/#requirements",
            "text": "To run Phaser Node Kit you will need  NodeJS  version 6 or higher. You can download the latest releases from the site at  https://nodejs.org .",
            "title": "Requirements"
        },
        {
            "location": "/install/#npm",
            "text": "Using the  npm  package manager (included with NodeJS), run the following on the command line:  sudo npm i -g phaser-node-kit  This will install the tool, and make it available anywhere on the command line as  pnkit .  You can get the latest version information to be certain its installed:  pnkit -v",
            "title": "npm"
        },
        {
            "location": "/cli/",
            "text": "Commands\n\n\nPhaser Node Kit\n only has a couple commands to get you up and running.\n\n\nInit\n\n\npnkit init\n\n\nTo create a new Phaser Node Kit project do the following:\n\n\n\n\n\n\nCreate a new empty directory.\n\n\n\n\n\n\nCreate a \npackage.json\n file (optional).\n\n\n\n\n\n\nRun \npnkit init\n on the command line in the directory you created.\n\n\n\n\n\n\n\n\nYou can create your own \npackage.json\n before running \npnkit init\n or a bare one will be created for you.\n\n\n\n\nWatch\n\n\nWatch the game development files, and trigger a build on changes:\n\n\npnkit watch\n\n\nPhaser Node Kit will now run a build when any of the files are updated. \n\n\nView the current game state in your browser at \nhttp://localhost:5550\n.\n\n\nYou can leave the browser window running, and it will refresh with each build.\n\n\nClean\n\n\nThere may be times when you want to clean the \nbuild\n directory between builds. You can do this using:\n\n\npnkit clean\n\n\nThis will flush the \nbuild\n folder and rebuild the project in its current state.\n\n\nA \nclean\n is run before each build takes place, so this command only has real usage in \"non-watched\" development.",
            "title": "Commands"
        },
        {
            "location": "/cli/#commands",
            "text": "Phaser Node Kit  only has a couple commands to get you up and running.",
            "title": "Commands"
        },
        {
            "location": "/cli/#init",
            "text": "pnkit init  To create a new Phaser Node Kit project do the following:    Create a new empty directory.    Create a  package.json  file (optional).    Run  pnkit init  on the command line in the directory you created.     You can create your own  package.json  before running  pnkit init  or a bare one will be created for you.",
            "title": "Init"
        },
        {
            "location": "/cli/#watch",
            "text": "Watch the game development files, and trigger a build on changes:  pnkit watch  Phaser Node Kit will now run a build when any of the files are updated.   View the current game state in your browser at  http://localhost:5550 .  You can leave the browser window running, and it will refresh with each build.",
            "title": "Watch"
        },
        {
            "location": "/cli/#clean",
            "text": "There may be times when you want to clean the  build  directory between builds. You can do this using:  pnkit clean  This will flush the  build  folder and rebuild the project in its current state.  A  clean  is run before each build takes place, so this command only has real usage in \"non-watched\" development.",
            "title": "Clean"
        },
        {
            "location": "/workflow/",
            "text": "Workflow\n\n\nSo here comes the \"fairly opinionated\" part.\n\n\nWhile there is nothing different about the coding in general, there are some design choices made on where files reside.\n\n\nBut before we go there, some context...\n\n\nSome Context\n\n\nI've been playing with games for nearly two and a half decades. I was an ActionScript developer from version 1 through 3, and have spent the last five working with the Lua game development community, mostly building server based tools.\n\n\nI heart making games, teaching, and developing tools and workflows to help people make games with less fuss. \n\n\nBeing able to hit the ground running when inspiration calls is crucial. I prototype constantly (or just noodle around) and don't like to spend time on tooling. \"Set it and forget it\" works great for me.\n\n\nThe goal for \nPhaser Node Kit\n was to be able to get to the \ncreative\n phase as quick as possible. \n\n\nSo with a \npnkit init\n\n\nAnd a \npnkit watch\n\n\nI'm looking at a \"live\" build in my browser ready to hack on, with a \nbuild\n folder ready to serve or bundle with something like \nCordova\n.\n\n\nOkay, enough context. On with the show. ^_^\n\n\nIndexes\n\n\nThe different index files have some basic data for their particular domain.\n\n\nindex.css\n\n\nThe included css file (\ngame/css/index.css\n) contains the page wide background color, as well as an implementation of \nclean.css\n which provides better visual compatibility across browsers.\n\n\nindex.html\n\n\nThe html entry point (\ngame/index.html\n) contains some standard scaffolding, as well as \napple-mobile-web\n meta tags.\n\n\nindex.js\n\n\nThe javascript entry point (\ngame/index.js\n) contains the \nstate\n assignments and a device render mode check:\n\n\n// PHASER IS IMPORTED AS AN EXTERNAL BUNDLE IN INDEX.HTML\nconst runPhaser = function(renderMode) {\n  const bootState     = require('./states/BootState')\n  const preloadState  = require('./states/PreloadState')\n  const menuState     = require('./states/MenuState')\n  const gameState     = require('./states/GameState')\n\n  const game = new Phaser.Game(800, 600, renderMode, 'game')\n\n  //add states\n  game.state.add('Boot',       bootState)\n  game.state.add('Preloader',  preloadState)\n  game.state.add('MainMenu',   menuState)\n  game.state.add('Game',       gameState)\n\n  //start the `boot` state\n  game.state.start('Boot')\n}\n\nPhaser.Device.whenReady(() => {\n  let renderMode = Phaser.CANVAS\n\n  if (Phaser.Device.desktop) {\n    renderMode = Phaser.WEBGL\n  } else if (Phaser.Device.android) {\n    if (Phaser.Device.isAndroidStockBrowser()) {\n      renderMode = Phaser.WEBGL\n    } else {\n      renderMode = Phaser.CANVAS\n    }\n\n  } else if (Phaser.Device.iOS) {\n    renderMode = Phaser.WEBGL\n  }\n\n  runPhaser(renderMode)\n})\n\n\n\n\nPhaser Node Kit States\n\n\nPhaser\n has an excellent state system to manange different game scenes; like the main menu, game play, IAP, etc. I tend to put as little as possible in the state files. Usually just boilerplate and configuration based code. \nPhaser Node Kit\n keeps all the state files in a \nstate\n directory inside of the main \njs\n folder.\n\n\nThere are four state files included, which run in the following order:\n\n\n\n\n\n\nBootState.js\n\n\n\n\n\n\nPreloadState.js\n\n\n\n\n\n\nMenuState.js\n\n\n\n\n\n\nGameState.js\n\n\n\n\n\n\nLets look inside...\n\n\n\n\nWhile I'm sure its obvious, from here on out we'll be using Node with es2015.\n\n\n\n\nBootState.js\n\n\nThe \nBootState\n is the first state that is run once \nPhaser\n is ready for it. It contains mostly configuration code, and preloads the \"loading\" bar into the image cache, which is used in the next state.\n\n\nclass BootState {\n\n  preload() {\n    this.stage.backgroundColor = 0x000000\n\n    this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL\n    this.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;\n\n    this.scale.setMinMax(300, 400)\n\n    this.scale.pageAlignVertically = true\n    this.scale.pageAlignHorizontally = true\n\n    if (Phaser.Device.desktop === false) {\n      this.scale.forceOrientation(false, true)\n    }\n\n    this.load.image('preload', 'img/preload.png')\n  }\n\n  create() {\n    this.input.maxPointers = 1\n    this.state.start('Preloader')\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = BootState\n\n\n\n\nIn particular, the \nBootState\n contains:\n\n\n\n\nBackground color\n\n\nScale mode\n\n\nFullscreen mode\n\n\nScale min/max\n\n\nContainer alignment\n\n\nOrientation setting\n\n\nmaxPointers setting\n\n\n\n\nIf you like your backgrounds black, and develop in an 800x600 display size, you never have to touch this file. ^_^\n\n\nOnce the \nBootState\n is done, it will automatically launch into the next state, which is the... \n\n\nPreloadState.js\n\n\nIn the \nPreloadState\n we load all of the assets needed for the game. While this is happening the \"loading\" bar will display the progress (I love free progress bars).\n\n\nclass PreloadState {\n  preload() {\n    this.preloadBar = null\n\n    this.preloadBar = this.game.add.sprite(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'preload')\n\n    this.preloadBar.anchor.set(.5)\n\n    this.load.setPreloadSprite(this.preloadBar)\n\n    this.load.image('logo', 'img/logo.png')\n    this.load.image('pnlogo', 'img/pnlogo.png')\n  }\n\n  create() {\n    this.state.start('MainMenu')\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = PreloadState\n\n\n\n\nAs far as states are concerned, you may visit this one most often to add additional assets to your game.\n\n\nOnce the \nPreloadState\n has run its course, it will load the \nMenuState\n.\n\n\nMenuState.js\n\n\nMain menus are generally not very complex. A background and a couple buttons is usually the bulk of it. The \nMenuState\n here is very minimal. We are simply displaying the \nPhaser\n logo, and the waiting for the \nonTap\n signal from the input manager.\n\n\nclass MenuState {\n  preload() { }\n\n  create() {\n    let logo = this.game.add.image(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'logo')\n\n    logo.anchor.set(.5)\n\n    this.input.onTap.addOnce((pointer) => {\n      this.state.start('Game')\n    })\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = MenuState\n\n\n\n\nDo what you will to it, but make sure to point to the \nGameState\n as your final destination (at least in this case).\n\n\nLet the game begin!\n\n\nGameState.js\n\n\nAhh, finally. Now we play. The \nGameState\n is just what it sounds like. Here is where your game takes flight. \n\n\nYou may be suprised to see this:\n\n\nconst Engine = require('../Engine')\n\nclass GameState {\n  preload() { }\n\n  create() {\n    this.engine = new Engine(this.game)\n    this.engine.run()\n  }\n\n  update() { this.engine.update() }\n  render() { this.engine.render() }\n}\n\nmodule.exports = GameState\n\n\n\n\nNot much of a game. But believe it or not, the \nGameState\n will probably be your \nleanest\n state.\n\n\nHere we are simply wiring up an external module. Its also where we jump off the state train, and move into our development domain.\n\n\nEngine.js\n\n\nA moment ago I mentioned that the \nGameState\n would be your \nleanest\n state. This is done by building modules in the root \njs\n directory and adding them to the \nGameState.js\n. This approach makes it really simple to change out your \nengine\n code with other alternatives for testing ideas, etc.\n\n\nHave a look at the \nEngine.js\n file in the root \njs\n directory. This is where we put the game \"controller\" code. This \nEngine.js\n module will be used to orchastrate the systems in your game, and makes it much easier to manage your game overall. A single point of entry and exit.\n\n\nA simple \nEngine.js\n:\n\n\nclass Engine {\n  constructor(game) {\n    this.game = game\n  }\n\n  run() {\n    let pnlogo = this.game.add.image(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'pnlogo')\n\n    pnlogo.anchor.set(.5)\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = Engine\n\n\n\n\nWe are simply taking in the \ngame\n reference and storing for use within the class, as well as, loading up an image for something to do. We've also added the \nupdate\n and \nrender\n methods that were wired up in the \nGameState.js\n file.\n\n\nAn important distinction to make here is that the \ngame\n property is an entry point to most of the Phaser library. In a state file, you can also access certain systems with a shorter syntax. This can cause mistakes when jumping into different coding contexts.\n\n\nAs an example, in the engine file we'd access the \nInput\n manager through the \ngame\n property:\n\n\nthis.game.input\n\n\n\n\nIn a state file (and only a state file) it can also be written like so:\n\n\nthis.input //wont work in Engine.js\n\n\n\n\nWhen looking at other code examples on the web, be sure to double check this if your results are unexpected.\n\n\nThe following code demonstrates \nthe\n common pattern when making any additional classes:\n\n\nclass SomeClass {\n  constructor(game) {\n    this.game = game\n  }\n}\n\nmodule.exports = SomeClass\n\n\n\n\nExtending Classes\n\n\nAgain, we are working in the root \njs\n folder now (and forever). As an example of extending a \nPhaser\n class, lets look at a Sprite:\n\n\nclass MySprite extends Phaser.Sprite {\n  constructor(game, x, y, img) {\n    super(game, x, y, img)\n\n    //look ma, I'm a Sprite!\n    this.alpha = .5\n  }\n}\n\nmodule.exports = MySprite\n\n\n\n\n\nUsage:\n\n\nconst MySprite = require('./mySprite.js')\n\nclass SomeClass {\n  constructor(game) {\n    this.game = game\n\n    this.sprite = new MySprite(this.game, 0, 0, 'logo')\n    this.sprite.anchor.set(.5)\n  }\n}\n\nmodule.exports = SomeClass\n\n\n\n\n\nNow, if you were to run the \nSomeClass\n nothing would be displayed on the screen. We must add the Sprite to the display list. This can be done in a couple of different ways, and happens on its own in some cases, such as adding the Sprite to a visible and active group.\n\n\nThe most direct way to add this Sprite to the display list is like so:\n\n\n//SomeClass constructor\nconstructor(game) {\n  this.game = game\n  let sprite = new MySprite(this.game, 0, 0, 'logo')\n\n  this.game.world.add(sprite)\n}\n\n\n\n\n\n\nIn most use cases, the sprite above should be put in a predefined group, rather than directly in the world.\n\n\n\n\nIf you have a group already on the display list, adding the Sprite will make it come alive:\n\n\n//SomeClass constructor\nconstructor(game, grp) {\n  this.game = game\n  this.grp = grp //on display list\n\n  let sprite = new MySprite(this.game, 0, 0, 'logo')\n  this.grp.add(sprite) //sprite becomes visible\n}",
            "title": "Workflow"
        },
        {
            "location": "/workflow/#workflow",
            "text": "So here comes the \"fairly opinionated\" part.  While there is nothing different about the coding in general, there are some design choices made on where files reside.  But before we go there, some context...",
            "title": "Workflow"
        },
        {
            "location": "/workflow/#some-context",
            "text": "I've been playing with games for nearly two and a half decades. I was an ActionScript developer from version 1 through 3, and have spent the last five working with the Lua game development community, mostly building server based tools.  I heart making games, teaching, and developing tools and workflows to help people make games with less fuss.   Being able to hit the ground running when inspiration calls is crucial. I prototype constantly (or just noodle around) and don't like to spend time on tooling. \"Set it and forget it\" works great for me.  The goal for  Phaser Node Kit  was to be able to get to the  creative  phase as quick as possible.   So with a  pnkit init  And a  pnkit watch  I'm looking at a \"live\" build in my browser ready to hack on, with a  build  folder ready to serve or bundle with something like  Cordova .  Okay, enough context. On with the show. ^_^",
            "title": "Some Context"
        },
        {
            "location": "/workflow/#indexes",
            "text": "The different index files have some basic data for their particular domain.",
            "title": "Indexes"
        },
        {
            "location": "/workflow/#indexcss",
            "text": "The included css file ( game/css/index.css ) contains the page wide background color, as well as an implementation of  clean.css  which provides better visual compatibility across browsers.",
            "title": "index.css"
        },
        {
            "location": "/workflow/#indexhtml",
            "text": "The html entry point ( game/index.html ) contains some standard scaffolding, as well as  apple-mobile-web  meta tags.",
            "title": "index.html"
        },
        {
            "location": "/workflow/#indexjs",
            "text": "The javascript entry point ( game/index.js ) contains the  state  assignments and a device render mode check:  // PHASER IS IMPORTED AS AN EXTERNAL BUNDLE IN INDEX.HTML\nconst runPhaser = function(renderMode) {\n  const bootState     = require('./states/BootState')\n  const preloadState  = require('./states/PreloadState')\n  const menuState     = require('./states/MenuState')\n  const gameState     = require('./states/GameState')\n\n  const game = new Phaser.Game(800, 600, renderMode, 'game')\n\n  //add states\n  game.state.add('Boot',       bootState)\n  game.state.add('Preloader',  preloadState)\n  game.state.add('MainMenu',   menuState)\n  game.state.add('Game',       gameState)\n\n  //start the `boot` state\n  game.state.start('Boot')\n}\n\nPhaser.Device.whenReady(() => {\n  let renderMode = Phaser.CANVAS\n\n  if (Phaser.Device.desktop) {\n    renderMode = Phaser.WEBGL\n  } else if (Phaser.Device.android) {\n    if (Phaser.Device.isAndroidStockBrowser()) {\n      renderMode = Phaser.WEBGL\n    } else {\n      renderMode = Phaser.CANVAS\n    }\n\n  } else if (Phaser.Device.iOS) {\n    renderMode = Phaser.WEBGL\n  }\n\n  runPhaser(renderMode)\n})",
            "title": "index.js"
        },
        {
            "location": "/workflow/#phaser-node-kit-states",
            "text": "Phaser  has an excellent state system to manange different game scenes; like the main menu, game play, IAP, etc. I tend to put as little as possible in the state files. Usually just boilerplate and configuration based code.  Phaser Node Kit  keeps all the state files in a  state  directory inside of the main  js  folder.  There are four state files included, which run in the following order:    BootState.js    PreloadState.js    MenuState.js    GameState.js    Lets look inside...   While I'm sure its obvious, from here on out we'll be using Node with es2015.",
            "title": "Phaser Node Kit States"
        },
        {
            "location": "/workflow/#bootstatejs",
            "text": "The  BootState  is the first state that is run once  Phaser  is ready for it. It contains mostly configuration code, and preloads the \"loading\" bar into the image cache, which is used in the next state.  class BootState {\n\n  preload() {\n    this.stage.backgroundColor = 0x000000\n\n    this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL\n    this.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;\n\n    this.scale.setMinMax(300, 400)\n\n    this.scale.pageAlignVertically = true\n    this.scale.pageAlignHorizontally = true\n\n    if (Phaser.Device.desktop === false) {\n      this.scale.forceOrientation(false, true)\n    }\n\n    this.load.image('preload', 'img/preload.png')\n  }\n\n  create() {\n    this.input.maxPointers = 1\n    this.state.start('Preloader')\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = BootState  In particular, the  BootState  contains:   Background color  Scale mode  Fullscreen mode  Scale min/max  Container alignment  Orientation setting  maxPointers setting   If you like your backgrounds black, and develop in an 800x600 display size, you never have to touch this file. ^_^  Once the  BootState  is done, it will automatically launch into the next state, which is the...",
            "title": "BootState.js"
        },
        {
            "location": "/workflow/#preloadstatejs",
            "text": "In the  PreloadState  we load all of the assets needed for the game. While this is happening the \"loading\" bar will display the progress (I love free progress bars).  class PreloadState {\n  preload() {\n    this.preloadBar = null\n\n    this.preloadBar = this.game.add.sprite(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'preload')\n\n    this.preloadBar.anchor.set(.5)\n\n    this.load.setPreloadSprite(this.preloadBar)\n\n    this.load.image('logo', 'img/logo.png')\n    this.load.image('pnlogo', 'img/pnlogo.png')\n  }\n\n  create() {\n    this.state.start('MainMenu')\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = PreloadState  As far as states are concerned, you may visit this one most often to add additional assets to your game.  Once the  PreloadState  has run its course, it will load the  MenuState .",
            "title": "PreloadState.js"
        },
        {
            "location": "/workflow/#menustatejs",
            "text": "Main menus are generally not very complex. A background and a couple buttons is usually the bulk of it. The  MenuState  here is very minimal. We are simply displaying the  Phaser  logo, and the waiting for the  onTap  signal from the input manager.  class MenuState {\n  preload() { }\n\n  create() {\n    let logo = this.game.add.image(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'logo')\n\n    logo.anchor.set(.5)\n\n    this.input.onTap.addOnce((pointer) => {\n      this.state.start('Game')\n    })\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = MenuState  Do what you will to it, but make sure to point to the  GameState  as your final destination (at least in this case).  Let the game begin!",
            "title": "MenuState.js"
        },
        {
            "location": "/workflow/#gamestatejs",
            "text": "Ahh, finally. Now we play. The  GameState  is just what it sounds like. Here is where your game takes flight.   You may be suprised to see this:  const Engine = require('../Engine')\n\nclass GameState {\n  preload() { }\n\n  create() {\n    this.engine = new Engine(this.game)\n    this.engine.run()\n  }\n\n  update() { this.engine.update() }\n  render() { this.engine.render() }\n}\n\nmodule.exports = GameState  Not much of a game. But believe it or not, the  GameState  will probably be your  leanest  state.  Here we are simply wiring up an external module. Its also where we jump off the state train, and move into our development domain.",
            "title": "GameState.js"
        },
        {
            "location": "/workflow/#enginejs",
            "text": "A moment ago I mentioned that the  GameState  would be your  leanest  state. This is done by building modules in the root  js  directory and adding them to the  GameState.js . This approach makes it really simple to change out your  engine  code with other alternatives for testing ideas, etc.  Have a look at the  Engine.js  file in the root  js  directory. This is where we put the game \"controller\" code. This  Engine.js  module will be used to orchastrate the systems in your game, and makes it much easier to manage your game overall. A single point of entry and exit.  A simple  Engine.js :  class Engine {\n  constructor(game) {\n    this.game = game\n  }\n\n  run() {\n    let pnlogo = this.game.add.image(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'pnlogo')\n\n    pnlogo.anchor.set(.5)\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = Engine  We are simply taking in the  game  reference and storing for use within the class, as well as, loading up an image for something to do. We've also added the  update  and  render  methods that were wired up in the  GameState.js  file.  An important distinction to make here is that the  game  property is an entry point to most of the Phaser library. In a state file, you can also access certain systems with a shorter syntax. This can cause mistakes when jumping into different coding contexts.  As an example, in the engine file we'd access the  Input  manager through the  game  property:  this.game.input  In a state file (and only a state file) it can also be written like so:  this.input //wont work in Engine.js  When looking at other code examples on the web, be sure to double check this if your results are unexpected.  The following code demonstrates  the  common pattern when making any additional classes:  class SomeClass {\n  constructor(game) {\n    this.game = game\n  }\n}\n\nmodule.exports = SomeClass",
            "title": "Engine.js"
        },
        {
            "location": "/workflow/#extending-classes",
            "text": "Again, we are working in the root  js  folder now (and forever). As an example of extending a  Phaser  class, lets look at a Sprite:  class MySprite extends Phaser.Sprite {\n  constructor(game, x, y, img) {\n    super(game, x, y, img)\n\n    //look ma, I'm a Sprite!\n    this.alpha = .5\n  }\n}\n\nmodule.exports = MySprite  Usage:  const MySprite = require('./mySprite.js')\n\nclass SomeClass {\n  constructor(game) {\n    this.game = game\n\n    this.sprite = new MySprite(this.game, 0, 0, 'logo')\n    this.sprite.anchor.set(.5)\n  }\n}\n\nmodule.exports = SomeClass  Now, if you were to run the  SomeClass  nothing would be displayed on the screen. We must add the Sprite to the display list. This can be done in a couple of different ways, and happens on its own in some cases, such as adding the Sprite to a visible and active group.  The most direct way to add this Sprite to the display list is like so:  //SomeClass constructor\nconstructor(game) {\n  this.game = game\n  let sprite = new MySprite(this.game, 0, 0, 'logo')\n\n  this.game.world.add(sprite)\n}   In most use cases, the sprite above should be put in a predefined group, rather than directly in the world.   If you have a group already on the display list, adding the Sprite will make it come alive:  //SomeClass constructor\nconstructor(game, grp) {\n  this.game = game\n  this.grp = grp //on display list\n\n  let sprite = new MySprite(this.game, 0, 0, 'logo')\n  this.grp.add(sprite) //sprite becomes visible\n}",
            "title": "Extending Classes"
        },
        {
            "location": "/config/",
            "text": "Configuration\n\n\nPhaser Node Kit\n is a fairly opinionated framework, so configuration options are minimal. You can however add some different resource paths to the build.\n\n\npnkit.json\n\n\nAll of the Phaser Node Kit project settings can be found in the \npnkit.json\n file at the root of the project directory. This file is critical to the tools operation. Don't lose it. ^_^\n\n\nThe default configuration file looks like so:\n\n\n{\n  \"build\": {\n    \"game\": [\n      \"data\",\n      \"font\"\n    ],\n    \"external\": []\n  }\n}\n\n\n\n\nConfiguration Keys\n\n\nbuild\n\n\nThe build section contains two keys holding arrays named \ngame\n and \nexternal\n, which can be used to \nextend\n the default directory settings.\n\n\ngame\n\n\nBy default the game template created with Phaser Node Kit is minimal. To add additional directories to your build, do the following:\n\n\n\n\n\n\nCreate the new directory in your \ngame\n folder.\n\n\n\n\n\n\nAdd an entry to the \ngame\n key array.\n\n\n\n\n\n\nIn the default config above, the directories \ndata\n and \nfont\n are added to the project as additional entries. If you don't need that functionality, you can remove the directories, as well as the entries in the \nbuild.game\n array.\n \n\n\nexternal\n\n\nIf you would like to include directories in the build from outside of the \ngame\n directory, you can add them to this array. The steps are the same as for the \ngame\n key above. \n\n\n\n\nJavascript files are only compiled if they live in the \ngame/js\n directory. Any other file type is copied directly to the \nbuild\n folder on each build.",
            "title": "Configuration"
        },
        {
            "location": "/config/#configuration",
            "text": "Phaser Node Kit  is a fairly opinionated framework, so configuration options are minimal. You can however add some different resource paths to the build.",
            "title": "Configuration"
        },
        {
            "location": "/config/#pnkitjson",
            "text": "All of the Phaser Node Kit project settings can be found in the  pnkit.json  file at the root of the project directory. This file is critical to the tools operation. Don't lose it. ^_^  The default configuration file looks like so:  {\n  \"build\": {\n    \"game\": [\n      \"data\",\n      \"font\"\n    ],\n    \"external\": []\n  }\n}",
            "title": "pnkit.json"
        },
        {
            "location": "/config/#configuration-keys",
            "text": "",
            "title": "Configuration Keys"
        },
        {
            "location": "/config/#build",
            "text": "The build section contains two keys holding arrays named  game  and  external , which can be used to  extend  the default directory settings.",
            "title": "build"
        },
        {
            "location": "/config/#game",
            "text": "By default the game template created with Phaser Node Kit is minimal. To add additional directories to your build, do the following:    Create the new directory in your  game  folder.    Add an entry to the  game  key array.    In the default config above, the directories  data  and  font  are added to the project as additional entries. If you don't need that functionality, you can remove the directories, as well as the entries in the  build.game  array.",
            "title": "game"
        },
        {
            "location": "/config/#external",
            "text": "If you would like to include directories in the build from outside of the  game  directory, you can add them to this array. The steps are the same as for the  game  key above.    Javascript files are only compiled if they live in the  game/js  directory. Any other file type is copied directly to the  build  folder on each build.",
            "title": "external"
        },
        {
            "location": "/notes/",
            "text": "Who turned out the lights?",
            "title": "Additional Notes"
        },
        {
            "location": "/issues/",
            "text": "Issues/Corrections\n\n\nI'll be the first to admit my time with \nPhaser\n isn't vast. I'm still learning this awesome library day by day. \n\n\nIf you spot a better way to do something, or a blantantly obvious mistake, please let me know by filing an issue on the GitHub repo at \nhttps://github.com/develephant/phaser-node-kit/issues\n.\n\n\n^_^ Happy Coding!",
            "title": "Issues/Corrections"
        },
        {
            "location": "/issues/#issuescorrections",
            "text": "I'll be the first to admit my time with  Phaser  isn't vast. I'm still learning this awesome library day by day.   If you spot a better way to do something, or a blantantly obvious mistake, please let me know by filing an issue on the GitHub repo at  https://github.com/develephant/phaser-node-kit/issues .  ^_^ Happy Coding!",
            "title": "Issues/Corrections"
        }
    ]
}