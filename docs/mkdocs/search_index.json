{
    "docs": [
        {
            "location": "/",
            "text": "Phaser Node Kit\n\n\nGame development using PhaserJS and NodeJS\n\n\nWhat Is It?\n\n\nPhaser Node Kit\n is a fairly opinionated workflow and build tool for creating \nPhaserJS\n games using \nNodeJS\n.\n\n\nYou may be asking yourself, why? And that I can't answer clearly. I just prefer the \nNodeJS\n stylings and spend most of my time in the \nNodeJS\n environment.\n\n\nThe build tool is basically a collection of some popular libraries to get your game built for distribution using \nNode\n.\n\n\nThe major components consist of:\n\n\nNodeJS\n\n\nBabel (es2015)\n\n\nBrowserify\n\n\nand of course...\n\n\nPhaserJS\n\n\nHow It Works\n\n\nOn each build cycle your javascript code is compiled to a \nBrowserify\n bundle ready to play. The \nphaser.js\n file is gathered from \nnpm\n and added as a vendor file during the initial creation of your project. See \nAdditional Notes\n for more information about the handling of the \nphaser.js\n library.\n\n\nPhaser Node Kit imposes a certain workflow, but provides a few entry points to handle unique situations. For straight forward game development the workflow should prove accommodating. See the \nWorkflow\n section for more details.",
            "title": "Overview"
        },
        {
            "location": "/#phaser-node-kit",
            "text": "Game development using PhaserJS and NodeJS",
            "title": "Phaser Node Kit"
        },
        {
            "location": "/#what-is-it",
            "text": "Phaser Node Kit  is a fairly opinionated workflow and build tool for creating  PhaserJS  games using  NodeJS .  You may be asking yourself, why? And that I can't answer clearly. I just prefer the  NodeJS  stylings and spend most of my time in the  NodeJS  environment.  The build tool is basically a collection of some popular libraries to get your game built for distribution using  Node .  The major components consist of:  NodeJS  Babel (es2015)  Browserify  and of course...  PhaserJS",
            "title": "What Is It?"
        },
        {
            "location": "/#how-it-works",
            "text": "On each build cycle your javascript code is compiled to a  Browserify  bundle ready to play. The  phaser.js  file is gathered from  npm  and added as a vendor file during the initial creation of your project. See  Additional Notes  for more information about the handling of the  phaser.js  library.  Phaser Node Kit imposes a certain workflow, but provides a few entry points to handle unique situations. For straight forward game development the workflow should prove accommodating. See the  Workflow  section for more details.",
            "title": "How It Works"
        },
        {
            "location": "/install/",
            "text": "Installation\n\n\nPhaser Node Kit\n is a \nNodeJS\n command line application that is installed \"globally\" making the tool at the ready for when creative game sparks land on your head.\n\n\nYou can have a running game framework up in a handful of seconds.\n\n\nRequirements\n\n\nTo run Phaser Node Kit you will need \nNodeJS\n version 6 or higher. You can download the latest releases from the site at \nhttps://nodejs.org\n.\n\n\nnpm\n\n\n\n\nPhaser Node Kit requires administrative privileges to work properly\n\n\n\n\nUsing the \nnpm\n package manager (included with NodeJS), run the following on the command line:\n\n\nsudo npm i -g phaser-node-kit\n\n\nThis will install the tool, and make it available anywhere on the command line as \npnkit\n.\n\n\nYou can get the latest version information to make sure its installed:\n\n\npnkit -v",
            "title": "Installation"
        },
        {
            "location": "/install/#installation",
            "text": "Phaser Node Kit  is a  NodeJS  command line application that is installed \"globally\" making the tool at the ready for when creative game sparks land on your head.  You can have a running game framework up in a handful of seconds.",
            "title": "Installation"
        },
        {
            "location": "/install/#requirements",
            "text": "To run Phaser Node Kit you will need  NodeJS  version 6 or higher. You can download the latest releases from the site at  https://nodejs.org .",
            "title": "Requirements"
        },
        {
            "location": "/install/#npm",
            "text": "Phaser Node Kit requires administrative privileges to work properly   Using the  npm  package manager (included with NodeJS), run the following on the command line:  sudo npm i -g phaser-node-kit  This will install the tool, and make it available anywhere on the command line as  pnkit .  You can get the latest version information to make sure its installed:  pnkit -v",
            "title": "npm"
        },
        {
            "location": "/cli/",
            "text": "Commands\n\n\nPhaser Node Kit\n only has a couple commands to get you up and running.\n\n\nInit\n\n\npnkit init\n\n\nTo create a new Phaser Node Kit project do the following:\n\n\n\n\n\n\nCreate a new empty directory.\n\n\n\n\n\n\nCreate a \npackage.json\n file (optional).\n\n\n\n\n\n\nRun \npnkit init\n on the command line in the directory you created.\n\n\n\n\n\n\npackage.json\n\n\nYou can create your own \npackage.json\n before running \npnkit init\n or a bare one will be created for you.\n\n\nIn either case the package.json file will be injected with some configuration settings. This file needs to stay with your project after initalization.\n\n\nBuild\n\n\nWhen you are ready to compile your files to your \nbuild\n directory, you run:\n\n\npnkit build\n\n\nThe should be done on the command line in the root project directory. The game \"distribution\" files will be contained in the \nbuild\n directory.\n\n\nAll files are flushed in the \nbuild\n directory on each build, so if you'd like a \"snapshot\" via git or other means, now is the time to do it.\n\n\nSee below for the \"watch\" build option.\n\n\nWatch\n\n\nIf you would like to watch the game development files, and trigger a build on changes, you use a slightly different command. This one references \nnpm\n:\n\n\nnpm run watch\n\n\nPhaser Node Kit will now run a build when any of the files are updated. Additonally you can view the current game state in your local browser. By default the url is \nhttp://localhost:5550\n.\n\n\nYou can leave the browser window running, and it will refresh with each build.\n\n\nFor other \"watch\" options see \nAdditional Notes\n.\n\n\nTo make adjustments to the watch server, see \nConfiguration\n.\n\n\nClean\n\n\nThere may be times when you want to clean the \nbuild\n directory between builds. You can do this using:\n\n\npnkit clean\n\n\nThis will flush the \nbuild\n folder and rebuild the project at its current state.\n\n\nA \nclean\n is run before each build takes place, so this command only has real usage in \"non-watched\" development.",
            "title": "Commands"
        },
        {
            "location": "/cli/#commands",
            "text": "Phaser Node Kit  only has a couple commands to get you up and running.",
            "title": "Commands"
        },
        {
            "location": "/cli/#init",
            "text": "pnkit init  To create a new Phaser Node Kit project do the following:    Create a new empty directory.    Create a  package.json  file (optional).    Run  pnkit init  on the command line in the directory you created.    package.json  You can create your own  package.json  before running  pnkit init  or a bare one will be created for you.  In either case the package.json file will be injected with some configuration settings. This file needs to stay with your project after initalization.",
            "title": "Init"
        },
        {
            "location": "/cli/#build",
            "text": "When you are ready to compile your files to your  build  directory, you run:  pnkit build  The should be done on the command line in the root project directory. The game \"distribution\" files will be contained in the  build  directory.  All files are flushed in the  build  directory on each build, so if you'd like a \"snapshot\" via git or other means, now is the time to do it.  See below for the \"watch\" build option.",
            "title": "Build"
        },
        {
            "location": "/cli/#watch",
            "text": "If you would like to watch the game development files, and trigger a build on changes, you use a slightly different command. This one references  npm :  npm run watch  Phaser Node Kit will now run a build when any of the files are updated. Additonally you can view the current game state in your local browser. By default the url is  http://localhost:5550 .  You can leave the browser window running, and it will refresh with each build.  For other \"watch\" options see  Additional Notes .  To make adjustments to the watch server, see  Configuration .",
            "title": "Watch"
        },
        {
            "location": "/cli/#clean",
            "text": "There may be times when you want to clean the  build  directory between builds. You can do this using:  pnkit clean  This will flush the  build  folder and rebuild the project at its current state.  A  clean  is run before each build takes place, so this command only has real usage in \"non-watched\" development.",
            "title": "Clean"
        },
        {
            "location": "/workflow/",
            "text": "Workflow\n\n\nSo here comes the \"fairly opinionated\" part.\n\n\nWhile there is nothing different about the coding in general, there are some design choices made on where files reside and how they are incorporated into the workflow that you need to be aware of.\n\n\nBut before we go there, some context...\n\n\nSome Context\n\n\nI've been playing with games for nearly two and a half decades. I was an ActionScript developer from version 1 through 3, and have spent the last five working with the Lua game development community, mostly building server based tools. I heart making games, teaching, and developing tools and workflows to help people make games with less fuss. Having discovered \nPhaser\n and brushing up with \nNode\n, I've found my ideal tool set. Having used this kit for a while now, I thought others might enjoy using it as well.\n\n\nOkay, enough context. ^_^\n\n\nThe Big Picture\n\n\nI like to get up and running quick when an idea hits me. I prototype constantly (or just noodle around) and don't like to spend time on tooling. Set it and forget works great for me.\n\n\nThe goal for \nPhaser Node Kit\n was to be able to get to the \ncreative\n phase as quick as possible. \n\n\nSo with a \npnkit init\n\n\nAnd a \nnpm run watch\n\n\nI'm looking at a \"live\" build in my browser ready to hack on, with a \nbuild\n folder ready to serve or bundle with something like \nCordova\n.\n\n\nI enjoy a certain amount of abstraction in code -- though sometimes a one-pager will do just fine. With \nPhaser Node Kit\n there is a level of abstraction in regards to \nPhaser\n states, which will be explained more below. Beyond that its pretty much business as usual for both \nPhaser\n and \nNode\n, assuming you keep a few things in mind.\n\n\nIndexes\n\n\nThe different index files have some basic data for their particular domain.\n\n\nindex.css\n\n\nThe included css file (\ngame/css/index.css\n) contains the page wide background color, as well as an implementation of \nclean.css\n which provides better visual compatibility across browsers.\n\n\nindex.html\n\n\nThe html entry point (\ngame/index.html\n) contains some standard scaffolding, as well as \napple-mobile-web\n meta tags.\n\n\nindex.js\n\n\nThe javascript entry point (\ngame/index.js\n) contains the \nstate\n assignments and a device render mode check:\n\n\n// PHASER IS IMPORTED AS AN EXTERNAL BUNDLE IN INDEX.HTML\nconst runPhaser = function(renderMode) {\n\n  renderMode = Phaser.CANVAS\n\n  /* States */\n  const bootState     = require('./states/BootState')\n  const preloadState  = require('./states/PreloadState')\n  const menuState     = require('./states/MenuState')\n  const gameState     = require('./states/GameState')\n\n  const game = new Phaser.Game(800, 600, renderMode, 'game')\n\n  //add states\n  game.state.add('Boot',       bootState)\n  game.state.add('Preloader',  preloadState)\n  game.state.add('MainMenu',   menuState)\n  game.state.add('Game',       gameState)\n\n  //start the `boot` state\n  game.state.start('Boot')\n\n}\n\nPhaser.Device.whenReady(() => {\n  let renderMode = Phaser.CANVAS\n\n  if (Phaser.Device.desktop) {\n    renderMode = Phaser.WEBGL\n  } else if (Phaser.Device.android) {\n    if (Phaser.Device.isAndroidStockBrowser()) {\n      renderMode = Phaser.WEBGL\n    } else {\n      renderMode = Phaser.CANVAS\n    }\n\n  } else if (Phaser.Device.iOS) {\n    renderMode = Phaser.WEBGL\n  }\n\n  runPhaser(renderMode)\n})\n\n\n\n\nStates\n\n\nPhaser Node Kit States\n\n\nPhaser\n has an excellent state system to manange different game scenes; like the main menu, game play, IAP, etc. I tend to put as little as possible in the state files. Usually just boilerplate and configuration based code. \nPhaser Node Kit\n keeps all the state files in a \nstate\n directory inside of the main \njs\n folder.\n\n\nThere are four state files included, which run in the following order:\n\n\n\n\n\n\nBootState.js\n\n\n\n\n\n\nPreloadState.js\n\n\n\n\n\n\nMenuState.js\n\n\n\n\n\n\nGameState.js\n\n\n\n\n\n\nLets look inside...\n\n\n\n\nWhile I'm sure its obvious, from here on out we'll be using Node and es2015.\n\n\n\n\nBootState.js\n\n\nThe \nBootState\n is the first state that is run once \nPhaser\n is ready for it. It contains mostly configuration code, and preloads the \"loading\" bar into the image cache, which is used in the next state.\n\n\nclass BootState {\n\n  preload() {\n    this.stage.backgroundColor = 0x000000\n\n    this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL\n    this.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;\n\n    this.scale.setMinMax(300, 400)\n\n    this.scale.pageAlignVertically = true\n    this.scale.pageAlignHorizontally = true\n\n    if (Phaser.Device.desktop === false) {\n      this.scale.forceOrientation(false, true)\n    }\n\n    this.load.image('preload', 'img/preload.png')\n  }\n\n  create() {\n    this.input.maxPointers = 1\n    this.state.start('Preloader')\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = BootState\n\n\n\n\nIn particular, the \nBootState\n contains:\n\n\n\n\nBackground color\n\n\nScale mode\n\n\nFullscreen mode\n\n\nScale min/max\n\n\nContainer alignment\n\n\nOrientation setting\n\n\nmaxPointers setting\n\n\n\n\nIf you like your backgrounds black, and develop in an 800x600 display size, you never have to touch this file. ^_^\n\n\nOnce the \nBootState\n is done, it automatically load the next state, which is the... \n\n\nPreloadState.js\n\n\nIn the \nPreloadState\n we load all of the assets needed for the game. While this is happening the \"loading\" bar will display the progress (I love free progress bars).\n\n\nclass PreloadState {\n\n  preload() {\n    this.preloadBar = null\n\n    this.preloadBar = this.game.add.sprite(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'preload')\n\n    this.preloadBar.anchor.set(.5)\n\n    this.load.setPreloadSprite(this.preloadBar)\n\n    this.load.image('logo', 'img/logo.png')\n    this.load.image('node', 'img/node.png')\n  }\n\n  create() {\n    this.state.start('MainMenu')\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = PreloadState\n\n\n\n\nAs far as states are concerned, you may visit this one most often to add additional assets to your game.\n\n\nOnce the \nPreloadState\n has run its course, it will load the \nMenuState\n.\n\n\nMenuState.js\n\n\nMain menus are generally not very complex. A background and a couple buttons is usually the bulk of it. The \nMenuState\n here is very minimal. We are simply displaying the \nPhaser\n logo, and the waiting for the \nonTap\n signal from the input manager.\n\n\nclass MenuState {\n  preload() { }\n\n  create() {\n    //bg\n    let logo = this.game.add.image(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'logo')\n\n    logo.anchor.set(.5)\n\n    this.input.onTap.addOnce((pointer) => {\n      this.state.start('Game')\n    })\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = MenuState\n\n\n\n\nDo what you will to it, but make sure to point to the \nGameState\n as your final destination (at least in this case).\n\n\nLet the game begin!\n\n\nGameState.js\n\n\nAhh, finally. Now we play. The \nGameState\n is just what it sounds like. Here is where your game takes flight. \n\n\nYou may be suprised to see this:\n\n\nclass GameState {\n  preload() { \n    console.log('game state started') \n  }\n\n  create() { \n    let node = this.game.add.image(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'node')\n\n    node.anchor.set(.5)\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = GameState\n\n\n\n\nNot much of a game. But believe it or not, the \nGameState\n will be your \nleanest\n state.\n\n\nHere we are simply displaying the \nNode\n logo for something to do. Its also where we jump off the state train, and move into our development domain.\n\n\nMaking An Engine\n\n\nA moment ago I mentioned that the \nGameState\n would be your \nleanest\n state. This is done by building some modules in the root \njs\n directory and adding them to the \nGameState.js\n. This approach makes it really simple to change out your \nengine\n code modules with other alternatives for testing ideas, etc.\n\n\nLets look at how this works in practice. First we need to create an \nengine.js\n file in the root \njs\n directory to put our game \"controller\" code in. This \nengine.js\n will be used to orchastrate the systems in your game. This makes it much easier to manage your game overall. A single point of entry and exit.\n\n\nFirst a simple \nengine.js\n:\n\n\nclass Engine {\n  constructor(game) {\n    this.game = game\n  }\n\n  run() {\n    console.log('engine started')\n  }\n}\n\nmodule.exports = Engine\n\n\n\n\nWe are simply taking in the \ngame\n reference and storing for use within the class.\n\n\n\n\nAn important distinction to make here is that the \ngame\n is an entry point to the Phaser library. In a state file, the \ngame\n is inferred. This can cause mistakes when jumping into different coding contexts.\n\n\n\n\nAs an example, in the engine file we'd use the following to access the input manager:\n\n\nthis.game.input\n\n\n\n\nIn a state file (and only a state file) it can also be written like so:\n\n\nthis.input //wont work in engine.js\n\n\n\n\nWhen looking at other code examples on the web, be sure to double check this if your results are unexpected.\n\n\nMoving on, it's time to wire up the \nengine.js\n to the \nGameState.js\n:\n\n\nGameState.js\n\n\nconst Engine = require('../engine')\n\nclass GameState {\n  preload() { }\n\n  create() {\n    let engine = new Engine(this).run()\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = GameState\n\n\n\n\n\nYour needs may vary, but I most often include my \nui.js\n here as well and pass it to the \nengine.js\n, ending up with something like:\n\n\nconst Ui = require('../ui')\nconst Engine = require('../engine)\n\nclass GameState() {\n  create() {\n    let ui = new Ui(this)\n    let engine = new Engine(this, ui)\n  }\n}\n\nmodule.exports = GameState\n\n\n\n\nAnd fire it all up in the \nengine.js\n:\n\n\nclass Engine() {\n  constructor(game, ui) {\n    this.game = game\n    this.ui = ui\n\n    this.ui.run() //assuming a run method\n    this.run()\n  }\n\n  run() {\n    console.log('engine started')\n  }\n}\n\nmodule.exports = Engine\n\n\n\n\nThe following code demonstrates \nthe\n common pattern when making any additional classes:\n\n\nclass SomeClass {\n  constructor(game) {\n    this.game = game\n  }\n}\n\nmodule.exports = SomeClass\n\n\n\n\nExtending Classes\n\n\nAgain, we are working in the root \njs\n folder now (and forever). As an example of extending a \nPhaser\n class, lets look at a Sprite:\n\n\nclass MySprite extends Phaser.Sprite {\n  constructor(game, x, y, img) {\n    super(game, x, y, img)\n\n    //look ma, I'm a Sprite!\n    this.alpha = .5\n  }\n}\n\nmodule.exports = MySprite\n\n\n\n\n\nUsage:\n\n\nconst MySprite = require('./mySprite.js')\n\nclass SomeClass {\n  constructor(game) {\n    this.game = game\n\n    this.sprite = new MySprite(this.game, 0, 0, 'logo')\n    this.sprite.anchor.set(.5)\n  }\n}\n\nmodule.exports = SomeClass\n\n\n\n\n\nNow, if you were to run the \nSomeClass\n nothing would be displayed on the screen. We must add the Sprite to the display list. This can be done in a couple of different ways, and happens on its own in some cases, such as adding the Sprite to a visible and active group.\n\n\nThe most direct way to add this Sprite to the display list is like so:\n\n\n//SomeClass constructor\nconstructor(game) {\n  this.game = game\n  let sprite = new MySprite(this.game, 0, 0, 'logo')\n\n  this.game.world.add(sprite)\n}\n\n\n\n\n\n\nIn most use cases, the sprite above should be put in a predefined group, rather than directly in the world.\n\n\n\n\nIf you have a group already on the display list, adding the Sprite will make it come alive:\n\n\n//SomeClass constructor\nconstructor(game, grp) {\n  this.game = game\n  this.grp = grp //on display list\n\n  let sprite = new MySprite(this.game, 0, 0, 'logo')\n  this.grp.add(sprite) //sprite becomes visible\n}",
            "title": "Workflow"
        },
        {
            "location": "/workflow/#workflow",
            "text": "So here comes the \"fairly opinionated\" part.  While there is nothing different about the coding in general, there are some design choices made on where files reside and how they are incorporated into the workflow that you need to be aware of.  But before we go there, some context...",
            "title": "Workflow"
        },
        {
            "location": "/workflow/#some-context",
            "text": "I've been playing with games for nearly two and a half decades. I was an ActionScript developer from version 1 through 3, and have spent the last five working with the Lua game development community, mostly building server based tools. I heart making games, teaching, and developing tools and workflows to help people make games with less fuss. Having discovered  Phaser  and brushing up with  Node , I've found my ideal tool set. Having used this kit for a while now, I thought others might enjoy using it as well.  Okay, enough context. ^_^",
            "title": "Some Context"
        },
        {
            "location": "/workflow/#the-big-picture",
            "text": "I like to get up and running quick when an idea hits me. I prototype constantly (or just noodle around) and don't like to spend time on tooling. Set it and forget works great for me.  The goal for  Phaser Node Kit  was to be able to get to the  creative  phase as quick as possible.   So with a  pnkit init  And a  npm run watch  I'm looking at a \"live\" build in my browser ready to hack on, with a  build  folder ready to serve or bundle with something like  Cordova .  I enjoy a certain amount of abstraction in code -- though sometimes a one-pager will do just fine. With  Phaser Node Kit  there is a level of abstraction in regards to  Phaser  states, which will be explained more below. Beyond that its pretty much business as usual for both  Phaser  and  Node , assuming you keep a few things in mind.",
            "title": "The Big Picture"
        },
        {
            "location": "/workflow/#indexes",
            "text": "The different index files have some basic data for their particular domain.",
            "title": "Indexes"
        },
        {
            "location": "/workflow/#indexcss",
            "text": "The included css file ( game/css/index.css ) contains the page wide background color, as well as an implementation of  clean.css  which provides better visual compatibility across browsers.",
            "title": "index.css"
        },
        {
            "location": "/workflow/#indexhtml",
            "text": "The html entry point ( game/index.html ) contains some standard scaffolding, as well as  apple-mobile-web  meta tags.",
            "title": "index.html"
        },
        {
            "location": "/workflow/#indexjs",
            "text": "The javascript entry point ( game/index.js ) contains the  state  assignments and a device render mode check:  // PHASER IS IMPORTED AS AN EXTERNAL BUNDLE IN INDEX.HTML\nconst runPhaser = function(renderMode) {\n\n  renderMode = Phaser.CANVAS\n\n  /* States */\n  const bootState     = require('./states/BootState')\n  const preloadState  = require('./states/PreloadState')\n  const menuState     = require('./states/MenuState')\n  const gameState     = require('./states/GameState')\n\n  const game = new Phaser.Game(800, 600, renderMode, 'game')\n\n  //add states\n  game.state.add('Boot',       bootState)\n  game.state.add('Preloader',  preloadState)\n  game.state.add('MainMenu',   menuState)\n  game.state.add('Game',       gameState)\n\n  //start the `boot` state\n  game.state.start('Boot')\n\n}\n\nPhaser.Device.whenReady(() => {\n  let renderMode = Phaser.CANVAS\n\n  if (Phaser.Device.desktop) {\n    renderMode = Phaser.WEBGL\n  } else if (Phaser.Device.android) {\n    if (Phaser.Device.isAndroidStockBrowser()) {\n      renderMode = Phaser.WEBGL\n    } else {\n      renderMode = Phaser.CANVAS\n    }\n\n  } else if (Phaser.Device.iOS) {\n    renderMode = Phaser.WEBGL\n  }\n\n  runPhaser(renderMode)\n})",
            "title": "index.js"
        },
        {
            "location": "/workflow/#states",
            "text": "",
            "title": "States"
        },
        {
            "location": "/workflow/#phaser-node-kit-states",
            "text": "Phaser  has an excellent state system to manange different game scenes; like the main menu, game play, IAP, etc. I tend to put as little as possible in the state files. Usually just boilerplate and configuration based code.  Phaser Node Kit  keeps all the state files in a  state  directory inside of the main  js  folder.  There are four state files included, which run in the following order:    BootState.js    PreloadState.js    MenuState.js    GameState.js    Lets look inside...   While I'm sure its obvious, from here on out we'll be using Node and es2015.",
            "title": "Phaser Node Kit States"
        },
        {
            "location": "/workflow/#bootstatejs",
            "text": "The  BootState  is the first state that is run once  Phaser  is ready for it. It contains mostly configuration code, and preloads the \"loading\" bar into the image cache, which is used in the next state.  class BootState {\n\n  preload() {\n    this.stage.backgroundColor = 0x000000\n\n    this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL\n    this.scale.fullScreenScaleMode = Phaser.ScaleManager.SHOW_ALL;\n\n    this.scale.setMinMax(300, 400)\n\n    this.scale.pageAlignVertically = true\n    this.scale.pageAlignHorizontally = true\n\n    if (Phaser.Device.desktop === false) {\n      this.scale.forceOrientation(false, true)\n    }\n\n    this.load.image('preload', 'img/preload.png')\n  }\n\n  create() {\n    this.input.maxPointers = 1\n    this.state.start('Preloader')\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = BootState  In particular, the  BootState  contains:   Background color  Scale mode  Fullscreen mode  Scale min/max  Container alignment  Orientation setting  maxPointers setting   If you like your backgrounds black, and develop in an 800x600 display size, you never have to touch this file. ^_^  Once the  BootState  is done, it automatically load the next state, which is the...",
            "title": "BootState.js"
        },
        {
            "location": "/workflow/#preloadstatejs",
            "text": "In the  PreloadState  we load all of the assets needed for the game. While this is happening the \"loading\" bar will display the progress (I love free progress bars).  class PreloadState {\n\n  preload() {\n    this.preloadBar = null\n\n    this.preloadBar = this.game.add.sprite(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'preload')\n\n    this.preloadBar.anchor.set(.5)\n\n    this.load.setPreloadSprite(this.preloadBar)\n\n    this.load.image('logo', 'img/logo.png')\n    this.load.image('node', 'img/node.png')\n  }\n\n  create() {\n    this.state.start('MainMenu')\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = PreloadState  As far as states are concerned, you may visit this one most often to add additional assets to your game.  Once the  PreloadState  has run its course, it will load the  MenuState .",
            "title": "PreloadState.js"
        },
        {
            "location": "/workflow/#menustatejs",
            "text": "Main menus are generally not very complex. A background and a couple buttons is usually the bulk of it. The  MenuState  here is very minimal. We are simply displaying the  Phaser  logo, and the waiting for the  onTap  signal from the input manager.  class MenuState {\n  preload() { }\n\n  create() {\n    //bg\n    let logo = this.game.add.image(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'logo')\n\n    logo.anchor.set(.5)\n\n    this.input.onTap.addOnce((pointer) => {\n      this.state.start('Game')\n    })\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = MenuState  Do what you will to it, but make sure to point to the  GameState  as your final destination (at least in this case).  Let the game begin!",
            "title": "MenuState.js"
        },
        {
            "location": "/workflow/#gamestatejs",
            "text": "Ahh, finally. Now we play. The  GameState  is just what it sounds like. Here is where your game takes flight.   You may be suprised to see this:  class GameState {\n  preload() { \n    console.log('game state started') \n  }\n\n  create() { \n    let node = this.game.add.image(\n      this.game.world.centerX, \n      this.game.world.centerY, \n      'node')\n\n    node.anchor.set(.5)\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = GameState  Not much of a game. But believe it or not, the  GameState  will be your  leanest  state.  Here we are simply displaying the  Node  logo for something to do. Its also where we jump off the state train, and move into our development domain.",
            "title": "GameState.js"
        },
        {
            "location": "/workflow/#making-an-engine",
            "text": "A moment ago I mentioned that the  GameState  would be your  leanest  state. This is done by building some modules in the root  js  directory and adding them to the  GameState.js . This approach makes it really simple to change out your  engine  code modules with other alternatives for testing ideas, etc.  Lets look at how this works in practice. First we need to create an  engine.js  file in the root  js  directory to put our game \"controller\" code in. This  engine.js  will be used to orchastrate the systems in your game. This makes it much easier to manage your game overall. A single point of entry and exit.  First a simple  engine.js :  class Engine {\n  constructor(game) {\n    this.game = game\n  }\n\n  run() {\n    console.log('engine started')\n  }\n}\n\nmodule.exports = Engine  We are simply taking in the  game  reference and storing for use within the class.   An important distinction to make here is that the  game  is an entry point to the Phaser library. In a state file, the  game  is inferred. This can cause mistakes when jumping into different coding contexts.   As an example, in the engine file we'd use the following to access the input manager:  this.game.input  In a state file (and only a state file) it can also be written like so:  this.input //wont work in engine.js  When looking at other code examples on the web, be sure to double check this if your results are unexpected.  Moving on, it's time to wire up the  engine.js  to the  GameState.js :  GameState.js  const Engine = require('../engine')\n\nclass GameState {\n  preload() { }\n\n  create() {\n    let engine = new Engine(this).run()\n  }\n\n  update() { }\n  render() { }\n}\n\nmodule.exports = GameState  Your needs may vary, but I most often include my  ui.js  here as well and pass it to the  engine.js , ending up with something like:  const Ui = require('../ui')\nconst Engine = require('../engine)\n\nclass GameState() {\n  create() {\n    let ui = new Ui(this)\n    let engine = new Engine(this, ui)\n  }\n}\n\nmodule.exports = GameState  And fire it all up in the  engine.js :  class Engine() {\n  constructor(game, ui) {\n    this.game = game\n    this.ui = ui\n\n    this.ui.run() //assuming a run method\n    this.run()\n  }\n\n  run() {\n    console.log('engine started')\n  }\n}\n\nmodule.exports = Engine  The following code demonstrates  the  common pattern when making any additional classes:  class SomeClass {\n  constructor(game) {\n    this.game = game\n  }\n}\n\nmodule.exports = SomeClass",
            "title": "Making An Engine"
        },
        {
            "location": "/workflow/#extending-classes",
            "text": "Again, we are working in the root  js  folder now (and forever). As an example of extending a  Phaser  class, lets look at a Sprite:  class MySprite extends Phaser.Sprite {\n  constructor(game, x, y, img) {\n    super(game, x, y, img)\n\n    //look ma, I'm a Sprite!\n    this.alpha = .5\n  }\n}\n\nmodule.exports = MySprite  Usage:  const MySprite = require('./mySprite.js')\n\nclass SomeClass {\n  constructor(game) {\n    this.game = game\n\n    this.sprite = new MySprite(this.game, 0, 0, 'logo')\n    this.sprite.anchor.set(.5)\n  }\n}\n\nmodule.exports = SomeClass  Now, if you were to run the  SomeClass  nothing would be displayed on the screen. We must add the Sprite to the display list. This can be done in a couple of different ways, and happens on its own in some cases, such as adding the Sprite to a visible and active group.  The most direct way to add this Sprite to the display list is like so:  //SomeClass constructor\nconstructor(game) {\n  this.game = game\n  let sprite = new MySprite(this.game, 0, 0, 'logo')\n\n  this.game.world.add(sprite)\n}   In most use cases, the sprite above should be put in a predefined group, rather than directly in the world.   If you have a group already on the display list, adding the Sprite will make it come alive:  //SomeClass constructor\nconstructor(game, grp) {\n  this.game = game\n  this.grp = grp //on display list\n\n  let sprite = new MySprite(this.game, 0, 0, 'logo')\n  this.grp.add(sprite) //sprite becomes visible\n}",
            "title": "Extending Classes"
        },
        {
            "location": "/config/",
            "text": "Configuration\n\n\nPhaser Node Kit\n is a fairly opinionated framework, so configuration options are minimal. You can however add some different resource paths, and adjust the watch server settings.\n\n\npnkit.json\n\n\nAll of the Phaser Node Kit project settings can be found in the \npnkit.json\n file at the root of the project directory. This file is critical to the tools operation. Don't lose it. ^_^\n\n\nThe default configuration file looks like so:\n\n\n{\n  \"build\": {\n    \"game\": [\n      \"data\",\n      \"font\"\n    ],\n    \"external\": []\n  },\n  \"port\": 5550,\n  \"interval\": 750,\n  \"serve\": \"build\",\n  \"watchexps\": [\n    \"game/** # npm run build\"\n  ],\n  \"quiet\": true\n}\n\n\n\n\nConfiguration Keys\n\n\nWhat follows is a detailed explanation of the \npnkit.json\n keys.\n\n\nbuild\n\n\nThe build section contains two keys holding arrays named \ngame\n and \nexternal\n, which can be used to adjust your source directories.\n\n\ngame\n\n\nBy default the game template created with Phaser Node Kit is minimal. To add additional directories to your build, do the following:\n\n\n\n\n\n\nCreate the new directory in your \ngame\n folder.\n\n\n\n\n\n\nAdd an entry to the \ngame\n key array.\n\n\n\n\n\n\nIn the default config above, the directories \ndata\n and \nfont\n are added to the project as additional entries. If you don't need that functionality, you can remove the directories, as well as the entries in the \npnkit.json\n file.\n \n\n\nexternal\n\n\nIf you would like to include directories in the build from outside of the \ngame\n directory, you can add them to this array. The steps are the same as for the \ngame\n key above. \n\n\nport\n\n\nThe port the watch server will use. The default port is 5550.\n\n\ninterval\n\n\nThe time in milliseconds between watch updates. The default is 750.\n\n\nserve\n\n\nThe directory that will be served up. The default is the \nbuild\n directory.\n\n\nwatchexps\n\n\nThe server watch expressions. \n\n\nThe default is to watch the \ngame\n directory and run a \"clean-n-build\" on changes.\n\n\nIn the config above, the pound sign (#) is not a comment, but a separator. Do not remove it. For more info see the \nlight-server\n entry below.\n\n\nquiet\n\n\nKeep the noise down on the watch server output. The default is \ntrue\n.\n\n\n\n\nlight-server\n\n\nPhaser Node Kit uses the crafty \nlight-server\n package to serve up your game in progress. You can learn more about its usage options at \nhttps://www.npmjs.com/package/light-server\n.",
            "title": "Configuration"
        },
        {
            "location": "/config/#configuration",
            "text": "Phaser Node Kit  is a fairly opinionated framework, so configuration options are minimal. You can however add some different resource paths, and adjust the watch server settings.",
            "title": "Configuration"
        },
        {
            "location": "/config/#pnkitjson",
            "text": "All of the Phaser Node Kit project settings can be found in the  pnkit.json  file at the root of the project directory. This file is critical to the tools operation. Don't lose it. ^_^  The default configuration file looks like so:  {\n  \"build\": {\n    \"game\": [\n      \"data\",\n      \"font\"\n    ],\n    \"external\": []\n  },\n  \"port\": 5550,\n  \"interval\": 750,\n  \"serve\": \"build\",\n  \"watchexps\": [\n    \"game/** # npm run build\"\n  ],\n  \"quiet\": true\n}",
            "title": "pnkit.json"
        },
        {
            "location": "/config/#configuration-keys",
            "text": "What follows is a detailed explanation of the  pnkit.json  keys.",
            "title": "Configuration Keys"
        },
        {
            "location": "/config/#build",
            "text": "The build section contains two keys holding arrays named  game  and  external , which can be used to adjust your source directories.",
            "title": "build"
        },
        {
            "location": "/config/#game",
            "text": "By default the game template created with Phaser Node Kit is minimal. To add additional directories to your build, do the following:    Create the new directory in your  game  folder.    Add an entry to the  game  key array.    In the default config above, the directories  data  and  font  are added to the project as additional entries. If you don't need that functionality, you can remove the directories, as well as the entries in the  pnkit.json  file.",
            "title": "game"
        },
        {
            "location": "/config/#external",
            "text": "If you would like to include directories in the build from outside of the  game  directory, you can add them to this array. The steps are the same as for the  game  key above.",
            "title": "external"
        },
        {
            "location": "/config/#port",
            "text": "The port the watch server will use. The default port is 5550.",
            "title": "port"
        },
        {
            "location": "/config/#interval",
            "text": "The time in milliseconds between watch updates. The default is 750.",
            "title": "interval"
        },
        {
            "location": "/config/#serve",
            "text": "The directory that will be served up. The default is the  build  directory.",
            "title": "serve"
        },
        {
            "location": "/config/#watchexps",
            "text": "The server watch expressions.   The default is to watch the  game  directory and run a \"clean-n-build\" on changes.  In the config above, the pound sign (#) is not a comment, but a separator. Do not remove it. For more info see the  light-server  entry below.",
            "title": "watchexps"
        },
        {
            "location": "/config/#quiet",
            "text": "Keep the noise down on the watch server output. The default is  true .",
            "title": "quiet"
        },
        {
            "location": "/config/#light-server",
            "text": "Phaser Node Kit uses the crafty  light-server  package to serve up your game in progress. You can learn more about its usage options at  https://www.npmjs.com/package/light-server .",
            "title": "light-server"
        },
        {
            "location": "/notes/",
            "text": "Who turned out the lights?",
            "title": "Additional Notes"
        },
        {
            "location": "/issues/",
            "text": "Issues/Corrections\n\n\nI'll be the first to admit my time with \nPhaser\n isn't vast. I'm still learning this awesome library day by day. \n\n\nIf you spot a better way to do something, or a blantantly obvious mistake, please let me know by filing an issue on the GitHub repo at \nhttps://github.com/develephant/phaser-node-kit/issues\n.\n\n\n^_^ Happy Coding!",
            "title": "Issues/Corrections"
        },
        {
            "location": "/issues/#issuescorrections",
            "text": "I'll be the first to admit my time with  Phaser  isn't vast. I'm still learning this awesome library day by day.   If you spot a better way to do something, or a blantantly obvious mistake, please let me know by filing an issue on the GitHub repo at  https://github.com/develephant/phaser-node-kit/issues .  ^_^ Happy Coding!",
            "title": "Issues/Corrections"
        }
    ]
}